---
title: 计算机与网络-总结
tags: 计算机网络
categories: 计算机与网络
cover: 'https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/images/cover6.png'
abbrlink: 41329
date: 2022-04-06 00:56:29
---

# 计算机与网络



## 1对称加密与非对称加密



### 1.1**对称加密**

密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；

**存在的问题:** 这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方,对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。



### **1.2.** **非对称加密**：

#### 理解：

使用非对称密钥时，小黑和小红都需要用计算机产生一对属于自己的密钥，公钥加密的信息只有其对应的私钥才能解开，且公钥和私钥之间不能互推。

<img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.jpg" alt="非对称加密" style="zoom: 67%;" />

首先需要交换它们的公钥

<img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%862.jpg" alt="非对称加密" style="zoom:67%;" />



然后小黑向小红发送敏感文件时可以用小红的公钥进行加密后传给小红，加密后的数据只能由小红的私钥才能解开，小黑也不能解开数据

![非对称加密](https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%863.png)

#### 回答：

**非对称加密**：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。



## 2.三次握手和四次挥手

### 理解：

​	![tcp报文首部](https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcp%E9%A6%96%E9%83%A8.webp)

- 1. **源端口和目的端口**:    各占2个字节，分别写入源端口和目的端口；
- 2. **序号**:  占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；
- 3. **确认号**:   占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；***\*若确认号为= N，则表明：到序号N-1为止的所有数据都已正确收到\****。
- 4.  **数据偏移**：  占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；这个字段实际上是指出TCP报文段的首部长度。由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的。
- 5. **保留** ：   占6位，保留为今后使用，但目前应置为0 。

**下面有6个控制位，用来说明本报文段的性质。**

- 6. **紧急URG：** 当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；
- 7.  **确认ACK**：  仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；
- 8.  **推送PSH**:   当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1

- 9. **复位RST**:     当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；

- 10. **同步SYN**:    在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；

- 11. **终止FIN**:     用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；

- 12. **窗口**:  占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其发送窗口的依据。

- 13. **检验和:**   占2字节，校验首部和数据这两部分； 

- 14. **紧急指针** :   占2字节。紧急指针仅在URG=1时才有意义,指出本报文段中的紧急数据的字节数；

- 15.  ***\*选项\****    长度可变，最长可达4字节。当没有使用“选项”时，TCP的首部长度是20字节





### 回答：





![三次握手](https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.gif)

#### **2.1三次握手**

- 第一次握手：客户端向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。
- 第二次握手：TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。
- 第三次握手：TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，确认号ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。



#### **2.2为什么不能两次握手？**

为防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。

如果客户端第一次握手发送SYN包确定连接时，可能因为某些原因发生滞留，并没有到达服务器，客户端为了建立连接会再发送一个SYN包去连接。如果两次握手的话，服务端返回SYN包和ACK包就建立了连接，而如果这时滞留的SYN包恢复连接到达服务端，则服务端认为这是第二个连接，进入等待数据状态。返回ACK包和SYN包。而客户端认为只建立了一个连接。造成状态不一致，这将导致不必要的错误和资源的浪费。如果三次握手。服务端收不到最后的ACK包。则不会认为建立连接成功。









#### **2.3四次挥手**



![四次挥手](https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.gif)



>客户端和服务端都可以发送关闭连接请求

比如客户端初始化的序列号ISA=100，服务端初始化的序列号ISA=300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。

- 第一次挥手：当客户端的数据都传输完成后（数据没发送完也可以请求，要停止发送数据）。客户端向服务端发出连接释放报文，释放连接报文包含FIN标志位(FIN=1)、序列号seq=1101(等于前面已经传送过来的数据的最后一个字节的序号加1，100+1+1000，其中的1是建立连接时占的一个序列号)，此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。                <u>**注意**</u>：    此时的客户端不能再发数据了，但可以接受数据
- 第二次挥手： 服务端收到客户端发的FIN报文后给客户端回复确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=1102(客户端FIN报文序列号1101+1)、序列号seq=2300(300+2000)。此时服务端处于关闭等待状态，而不是立马给客户端发FIN报文，这个状态还要持续一段时间，因为服务端可能还有数据没发完。客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）
- 第三次挥手： 服务端将最后数据(比如50个字节)发送完毕后就向客户端发出连接释放报文，报文包含FIN和ACK标志位(FIN=1,ACK=1)、确认号和第二次挥手一样ack=1102、序列号seq=2350(2300+50)。服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认
- 第四次挥手： 客户端收到服务端发的FIN报文后，向服务端发出确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=2351、序列号seq=1102。注意客户端发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接。而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些。











#### **2.4如果已经建立了连接，但是客户端突然出现故障了怎么办？**

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。





#### **2.5为什么建立连接是三次握手，关闭连接确是四次挥手呢？**



建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。
而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。







## 3HTTP和HTTPS

### 理解：

https传输过程中有三个密钥。

- 服务器端生成的公钥和私钥，非对称加密。用于传输对称加密的密钥
- 客户端生成的随机密钥，用于对称加密

**传输过程：**

1. 客户端向服务器发起HTTPS请求，连接到服务器的443端口。
2. 服务器端生成一对公钥和私钥。私钥不能泄漏，公钥可以任意发送。（详见上面对称加密和非对称加密）
3. 服务器把公钥发给客户端
4. 客户端收到服务器端的公钥之后，会对公钥进行检查，验证其合法性，如果发现发现公钥有问题，那么HTTPS传输就无法继续。【严格的说，这里应该是验证服务器发送的数字证书的合法性】如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。
5. 客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。
6. 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。
7. 然后服务器将加密后的密文发送给客户端。
8. 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。







### 3.1 区别

- http默认使用端口为80，https默认使用端口为443
- http传输是明文传输，不安全。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。









